# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class PyEvtxParser:
    r"""
    PyEvtxParser(self, path_or_file_like, number_of_threads=0, ansi_codec='windows-1252', /)
    --
    
    Returns an instance of the parser.
    
    Args:
        `path_or_file_like`: a path (string), or a file-like object.
    
        `number_of_threads` (int, optional):
               limit the number of worker threads used by rust.
               `0` (the default) will let the library decide how many threads to use
               based on the number of cores available.
    
        `ansi_codec`(str, optional) to control encoding of ansi strings inside the evtx file.
    
                     Possible values:
                         ascii, ibm866, iso-8859-1, iso-8859-2, iso-8859-3, iso-8859-4,
                         iso-8859-5, iso-8859-6, iso-8859-7, iso-8859-8, iso-8859-10,
                         iso-8859-13, iso-8859-14, iso-8859-15, iso-8859-16,
                         koi8-r, koi8-u, mac-roman, windows-874, windows-1250, windows-1251,
                         windows-1252, windows-1253, windows-1254, windows-1255,
                         windows-1256, windows-1257, windows-1258, mac-cyrillic, utf-8,
                         windows-949, euc-jp, windows-31j, gbk, gb18030, hz, big5-2003,
                         pua-mapped-binary, iso-8859-8-i
    """
    def __new__(cls, path_or_file_like: typing.Any, number_of_threads: typing.Optional[builtins.int] = None, ansi_codec: typing.Optional[builtins.str] = None, validate_checksums: typing.Optional[builtins.bool] = None, separate_json_attributes: typing.Optional[builtins.bool] = None, indent: typing.Optional[builtins.bool] = None, wevt_cache: typing.Optional[typing.Any] = None) -> PyEvtxParser: ...
    def records(self) -> PyRecordsIterator:
        r"""
        records(self, /)
        --
        
        Returns an iterator that yields either an XML record, or a `RuntimeError` object.
        
        Note - Iterating over records can raise a `RuntimeError` if the parser encounters an invalid record.
               If using a regular for-loop, this could abruptly terminate the iteration.
        
               It is recommended to wrap this iterator with a logic that will continue iteration
               in case an exception object is returned.
        """
    def records_json(self) -> PyRecordsIterator:
        r"""
        records_json(self, /)
        --
        
        Returns an iterator that yields either a JSON record, or a `RuntimeError` object.
        
        Note - Iterating over records can raise a `RuntimeError` if the parser encounters an invalid record.
               If using a regular for-loop, this could abruptly terminate the iteration.
        
               It is recommended to wrap this iterator with a logic that will continue iteration
               in case an exception object is returned.
        """
    def __iter__(self) -> PyRecordsIterator: ...
    def __next__(self) -> typing.Optional[typing.Any]: ...

@typing.final
class PyRecordsIterator:
    def __iter__(self) -> PyRecordsIterator: ...
    def __next__(self) -> typing.Optional[typing.Any]: ...

@typing.final
class WevtCache:
    def __new__(cls) -> WevtCache: ...
    @staticmethod
    def load(path: typing.Any) -> WevtCache:
        r"""
        load(path, /)
        --
        
        Load a WEVT template cache file (`.wevtcache`) produced by:
        `evtx_dump extract-wevt-templates --output cache.wevtcache ...`
        """
    def add_dll(self, path: typing.Any) -> builtins.int:
        r"""
        add_dll(self, path, /)
        --
        
        Parse a PE file (EXE/DLL/SYS) and add any `WEVT_TEMPLATE` resources to this cache.
        
        This is **strict**: failures to read/parse inputs raise exceptions.
        """
    def add_dir(self, path: typing.Any, recursive: builtins.bool = True, extensions: typing.Optional[builtins.str] = None) -> builtins.int:
        r"""
        add_dir(self, path, recursive=True, extensions="exe,dll,sys", /)
        --
        
        Walk a directory and call `add_dll()` for all matching files.
        """
    def dump(self, path: typing.Any, overwrite: builtins.bool = False) -> None:
        r"""
        dump(self, path, overwrite=False, /)
        --
        
        Dump this in-memory cache to a single `.wevtcache` file.
        """
    def __repr__(self) -> builtins.str: ...
    def resolve_template_guid(self, provider_guid: builtins.str, event_id: builtins.int, version: builtins.int) -> builtins.str:
        r"""
        resolve_template_guid(self, provider_guid, event_id, version, /)
        --
        
        Resolve a template GUID using the cache index mapping of:
        (provider_guid, event_id, version) -> template_guid.
        """
    def render_template_xml(self, template_guid: builtins.str, substitutions: typing.Any, ansi_codec: typing.Optional[builtins.str] = None) -> builtins.str:
        r"""
        render_template_xml(self, template_guid, substitutions, ansi_codec=None, /)
        --
        
        Render a WEVT template to XML using substitution values (Python primitives).
        
        `substitutions` should be a list of values like: None/bool/int/float/str/bytes.
        """
    def render_record_xml(self, evtx_path_or_file_like: typing.Any, record_id: builtins.int, template_instance_index: builtins.int = 0, template_guid: typing.Optional[builtins.str] = None, provider_guid: typing.Optional[builtins.str] = None, event_id: typing.Optional[builtins.int] = None, version: typing.Optional[builtins.int] = None, ansi_codec: typing.Optional[builtins.str] = None) -> builtins.str:
        r"""
        render_record_xml(self, evtx_path_or_file_like, record_id, template_instance_index=0, template_guid=None, provider_guid=None, event_id=None, version=None, ansi_codec=None, /)
        --
        
        End-to-end offline rendering:
        - Extract TemplateInstance substitution values from an EVTX record.
        - Resolve the template GUID (either directly, or from provider_guid/event_id/version).
        - Render the template to XML using the offline cache.
        """

